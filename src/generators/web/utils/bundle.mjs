import virtual from '@rollup/plugin-virtual';
import { build } from 'rolldown';

import cssLoader from './css.mjs';
import staticData from './data.mjs';

/**
 * Asynchronously bundles JavaScript source code (and its CSS imports),
 * targeting either browser (client) or server (Node.js) environments.
 *
 * @param {Map<string, string>} codeMap - Map of {fileName: code} for all builds.
 * @param {Object} [options] - Build configuration object.
 * @param {boolean} [options.server=false] - Whether this is a server-side build.
 */
export default async function bundleCode(codeMap, { server = false } = {}) {
  // Store the import map HTML for later extraction
  let importMapHtml = '';

  /** @type {import('rolldown').OutputOptions} */
  const serverOutputConfig = {
    // Inline all dynamic imports to create a single self-contained bundle
    inlineDynamicImports: true,
  };

  /** @type {import('rolldown').InputOptions['experimental']} */
  const clientExperimentalConfig = {
    // Generate an import map for cache-busted module resolution in browsers
    // https://rolldown.rs/options/experimental#chunkimportmap
    chunkImportMap: {
      baseUrl: './',
      fileName: 'importmap.json',
    },
  };

  const result = await build({
    // Entry points: array of virtual module names that the virtual plugin provides
    input: Array.from(codeMap.keys()),

    // Experimental features: import maps for client, none for server
    experimental: server ? {} : clientExperimentalConfig,

    // Output configuration
    output: {
      // Output module format:
      // - "cjs" for CommonJS (used in Node.js environments)
      // - "esm" for browser environments (Using Chunk Code-Splitting)
      format: server ? 'cjs' : 'esm',

      // Minify output only for browser builds to optimize file size.
      // Server builds are usually not minified to preserve stack traces and debuggability.
      minify: !server,

      // Environment-specific output configuration
      ...(server ? serverOutputConfig : {}),
    },

    // Platform informs Rolldown of the environment-specific code behavior:
    // - 'node' enables things like `require`, and skips polyfills.
    // - 'browser' enables inlining of polyfills and uses native browser features.
    platform: server ? 'node' : 'browser',

    // External dependencies to exclude from bundling.
    // These are expected to be available at runtime in the server environment.
    // This reduces bundle size and avoids bundling shared server libs.
    external: server
      ? ['preact', 'preact-render-to-string', '@node-core/ui-components']
      : [],

    transform: {
      // Inject global compile-time constants that will be replaced in code.
      // These are useful for tree-shaking and conditional branching.
      // Be sure to update type declarations (`types.d.ts`) if these change.
      define: {
        // Static data injected directly into the bundle (as a literal or serialized JSON).
        __STATIC_DATA__: staticData,

        // Boolean flags used for conditional logic in source code:
        // Example: `if (SERVER) {...}` or `if (CLIENT) {...}`
        // These flags help split logic for server/client environments.
        // Unused branches will be removed via tree-shaking.
        SERVER: String(server),
        CLIENT: String(!server),
      },

      // JSX transformation configuration.
      // `'react-jsx'` enables the automatic JSX runtime, which doesn't require `import React`.
      // Since we're using Preact via aliasing, this setting works well with `preact/compat`.
      jsx: 'react-jsx',
    },

    // Module resolution aliases.
    // This tells the bundler to use `preact/compat` wherever `react` or `react-dom` is imported.
    // Allows you to write React-style code but ship much smaller Preact bundles.
    resolve: {
      alias: {
        react: 'preact/compat',
        'react-dom': 'preact/compat',
      },
    },

    // Array of plugins to apply during the build.
    plugins: [
      // Virtual plugin: provides in-memory modules from codeMap
      virtual(Object.fromEntries(codeMap)),

      // Load CSS imports via the custom plugin.
      // This plugin will collect imported CSS files and return them as `source` chunks.
      cssLoader(),

      // Extract and transform the import map generated by Rolldown
      {
        name: 'extract-import-map',
        /**
         * Extracts import map from bundle and converts to HTML script tag.
         *
         * @param {import('rolldown').NormalizedOutputOptions} _ - Output options (unused).
         * @param {import('rolldown').OutputBundle} bundle - Bundle object containing all output chunks.
         */
        generateBundle(_, bundle) {
          const chunkImportMap = bundle['importmap.json'];

          if (chunkImportMap?.type === 'asset') {
            // Convert to HTML script tag for inline inclusion
            importMapHtml = `<script type="importmap">${chunkImportMap.source}</script>`;

            // Remove from bundle to prevent writing as separate file
            delete bundle['importmap.json'];
          }
        },
      },
    ],

    // Enable tree-shaking to remove unused code
    treeshake: true,

    // Return chunks in memory instead of writing to disk
    write: false,
  });

  // Separate CSS assets from JavaScript chunks
  const cssFiles = result.output.filter(chunk => chunk.type === 'asset');
  const jsChunks = result.output.filter(chunk => chunk.type === 'chunk');

  return {
    importMapHtml,
    css: cssFiles.map(f => f.source).join(''),
    jsChunks: jsChunks.map(({ fileName, code, isEntry }) => ({
      fileName: fileName.replace('_virtual_', ''),
      code,
      isEntry,
    })),
  };
}
