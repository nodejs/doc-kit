import virtual from '@rollup/plugin-virtual';
import { build } from 'rolldown';

import cssLoader from './css.mjs';
import staticData from './data.mjs';

/**
 * Asynchronously bundles JavaScript source code (and its CSS imports),
 * targeting either browser (client) or server (Node.js) environments.
 *
 * @param {Map<string, string>} codeMap - Map of {fileName: code} for all builds.
 * @param {Object} [options] - Build configuration object.
 * @param {boolean} [options.server=false] - Whether this is a server-side build.
 */
export default async function bundleCode(codeMap, { server = false } = {}) {
  // Store the import map HTML for later extraction
  let importMapHtml = '';

  /** @type {import('rolldown').OutputOptions} */
  const serverOutputConfig = {
    // Inline all dynamic imports to create a single self-contained bundle
    inlineDynamicImports: true,
  };

  /** @type {import('rolldown').InputOptions['experimental']} */
  const clientExperimentalConfig = {
    // Generate an import map for cache-busted module resolution in browsers
    // https://rolldown.rs/options/experimental#chunkimportmap
    chunkImportMap: !server && {
      baseUrl: './',
      fileName: 'importmap.json',
    },
  };

  const result = await build({
    // Entry points: array of virtual module names that the virtual plugin provides
    input: Array.from(codeMap.keys()),

    // Experimental features: import maps for client, none for server
    experimental: server ? {} : clientExperimentalConfig,

    // Output configuration
    output: {
      // CommonJS for Node.js server, ESM for browser with code splitting support
      format: server ? 'cjs' : 'esm',

      // Minify only browser builds to reduce file size
      minify: !server,

      // Environment-specific output configuration
      ...(server ? serverOutputConfig : {}),
    },

    // Target platform affects polyfills, globals, and bundling behavior
    platform: server ? 'node' : 'browser',

    // External dependencies (not bundled) for server builds
    // These must be available in the Node.js runtime environment
    external: server
      ? ['preact', 'preact-render-to-string', '@node-core/ui-components']
      : [],

    // Transform and define configuration
    transform: {
      // Compile-time constants replaced during bundling
      // Update types.d.ts if these change
      define: {
        // Static data as a JSON literal
        __STATIC_DATA__: staticData,

        // Environment flags for conditional logic and tree-shaking
        SERVER: String(server),
        CLIENT: String(!server),
      },

      // Use automatic JSX runtime (no need to import React/Preact)
      jsx: 'react-jsx',
    },

    // Module resolution: alias React imports to Preact
    resolve: {
      alias: {
        react: 'preact/compat',
        'react-dom': 'preact/compat',
      },
    },

    // Build plugins
    plugins: [
      // Virtual plugin: provides in-memory modules from codeMap
      virtual(Object.fromEntries(codeMap)),

      // CSS loader: collects and bundles imported CSS files
      cssLoader(),

      // Extract and transform the import map generated by Rolldown
      {
        name: 'extract-import-map',
        /**
         * Extracts import map from bundle and converts to HTML script tag.
         *
         * @param {import('rolldown').NormalizedOutputOptions} _ - Output options (unused).
         * @param {import('rolldown').OutputBundle} bundle - Bundle object containing all output chunks.
         */
        generateBundle(_, bundle) {
          const chunkImportMap = bundle['importmap.json'];

          if (chunkImportMap?.type === 'asset') {
            // Convert to HTML script tag for inline inclusion
            importMapHtml = `<script type="importmap">${chunkImportMap.source}</script>`;

            // Remove from bundle to prevent writing as separate file
            delete bundle['importmap.json'];
          }
        },
      },
    ],

    // Enable tree-shaking to remove unused code
    treeshake: true,

    // Return chunks in memory instead of writing to disk
    write: false,
  });

  // Separate entry chunks (main modules) from other chunks (CSS, code-split JS)
  const entryChunks = [];
  const otherChunks = [];

  for (const chunk of result.output) {
    const chunkTarget =
      chunk.type === 'chunk' && chunk.isEntry ? entryChunks : otherChunks;

    chunkTarget.push(chunk);
  }

  // Separate CSS assets from JavaScript chunks
  const cssFiles = otherChunks.filter(chunk => chunk.type === 'asset');
  const jsChunks = otherChunks.filter(chunk => chunk.type === 'chunk');

  // Create a map of entry code by original fileName
  const jsMap = {};

  for (const chunk of entryChunks) {
    // Extract original fileName from virtual module ID
    const originalFileName =
      chunk.facadeModuleId?.split('/').pop() || chunk.fileName;

    // Remove virtual: prefix from module IDs
    jsMap[originalFileName.replace('\x00virtual:', '')] = chunk.code;
  }

  return {
    jsMap,
    jsChunks: jsChunks.map(({ fileName, code }) => ({ fileName, code })),
    css: cssFiles.map(f => f.source).join(''),
    importMapHtml,
  };
}
